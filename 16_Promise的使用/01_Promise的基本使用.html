<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 1、传统写法：链式回调地狱
    // setTimeout(() => {
    //   console.log('最外层')
    //   setTimeout(() => {
    //     console.log('第二层')
    //     setTimeout(() => {
    //       console.log('第三层')
    //       setTimeout(() => {
    //         console.log('第四层')
    //       }, 1000);
    //     }, 1000);
    //   }, 1000);
    // }, 1000);

    // 2、Promise的写法(将网络请求和处理请求结果拆分开来了)
    // new Promise((resolve,reject)=>{

    //   // 第一次发送网络请求
    //   setTimeout(() => {
    //     resolve("最外层")  // 请求成功调用该函数,参数就是网络请求的结果,调用该方法会把该函数的参数传递给下边的then函数
    //   }, 1000);

    // }).then((data)=>{
    //   // 第一次拿到网络请求返回的数据
    //   console.log(data)

    //   return new Promise((resolve,reject)=>{

    //     // 第二次发送网络请求
    //     setTimeout(() => {
    //       resolve("第二层")
    //     }, 1000);

    //   })
    // }).then((data2)=>{
    //   // 第二次处理网络请求返回的数据
    //   console.log(data2)

    //   return new Promise((resolve,reject)=>{

    //     // 第三次发送网络请求
    //     setTimeout(() => {
    //       resolve('第三层')
    //     }, 1000);
    //   })
    // }).then((data3)=>{
    //   // 第三次处理网络请求结果
    //   console.log(data3)

    //   return new Promise((resolve,reject)=>{

    //     // 第四次发送网络请求
    //     setTimeout(() => {
    //       reject('第四层报错啦！！！')     // 请求失败调用reject函数
    //     }, 1000);
    //   })
    // }).then((data4)=>{
    //   // 第四次处理网络请求结果
    //   console.log("then块：" + data4);
    // }).catch((err)=>{
    //   console.log("catch块：" + err);
    // })


    // 3、另外的写法
    new Promise((resolve,reject)=>{
      setTimeout(() => {
        // resolve('网络请求成功返回的结果')
        reject("网络请求失败返回的结果")
      }, 1000);
    }).then(
      data => {
        console.log('成功' + data);
      },
      err => {
        console.log('失败' + err);
      }
    )
  </script>
</body>
</html>